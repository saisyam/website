<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="/atom.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2021-02-13T19:11:44+05:30</updated><id>/atom.xml</id><title type="html">Saisyam</title><subtitle>Personal Blog</subtitle><author><name>Saisyam</name><email>saisyam@saisyam.com</email></author><entry><title type="html">What are Cloud native apps?</title><link href="/what-are-cloud-native-apps/" rel="alternate" type="text/html" title="What are Cloud native apps?" /><published>2020-10-15T00:00:00+05:30</published><updated>2020-10-15T00:00:00+05:30</updated><id>/what-are-cloud-native-apps</id><content type="html" xml:base="/what-are-cloud-native-apps/">Cloud native is an approach to building and running applications that exploits the advantages of the cloud computing delivery model. In simple terms, Cloud native applications are built using cloud-based technologies, fully hosted and managed in the cloud.


## Cloud Native approach
Here we will discuss about the four major components of Cloud native development:

1. Microservices
2. Containers
3. DevOps
4. CI/CD


## Microservices
Microservices are small modular and loosely coupled services. Each microservice will perform a single task, [single responsibility principle](https://en.wikipedia.org/wiki/Single-responsibility_principle). Loose coupling and service based design will help organizations increase their application creation speed without increasing complexity. Microservices run in their own process and communicate via HTTP APIs or messaging. Each microservice can be deployed, upgraded, scaled and restarted independent of other services in the application.

## Containers
Containers (running instances of dockers) provide both efficiency and speed when compared to virtual machines. They use Operating System (OS) level virtualization, where one instance of OS services is divided across various containers. To know more about dockers and containers read my article [here](https://saisyam.com/understanding-dockers-and-containers/). The low overhead of creating/destroying and starting/stopping containers make them ideal to deploy microservices. We can run multiple containers in a single VM.

## DevOps
DevOps is a collaboration between developers and operations with a goal of constantly delivering high quality software. Early adoption of DevOps culture into the organization will help accelerate the path to cloud0-native applications and deploy apps faster and more efficiently. DevOps adoption not only relies on tools and technologies, but also the mindset, willingness and trust of the people to collaborative to develop and deliver applications.

## CI/CD
CI/CD is all about shipping small batches of software to production frequently through automation. Automation of continuous delivery will help organizations to quicky and efficiently deliver updated software to production without bringing down the whole system.   


## Advantages of Cloud native development approach
Our traditional development approach is mostly monolith. We will create an application with different modules doing differen tasks. For example, in a shopping cart application, we have modules for product management, user management, billing, etc. But all these are tightly coupled with each other which makes it difficult to make any changes to an individual module without disturbing the others.

This is a successful model till date. Then **why we need to shift to cloud native approach?** To answer this, let's see the differences between traditional and cloud native approaches from different perspectives. Below table will illustrate that:


|                          | Traditional Approach                    | Cloud native Approach |
|------------------------|-----------------------------------------|-----------------------|
| Development Methodology  | Waterfall                               | Agile, DevOps, CI/CD  |
| Design/Architecture | Tightly coupled, monolith | loosely coupled, API/Message based communication, single responsibility principle |
| Workforce                | Isolated development, operations, QA and delivery teams| DevOps teams |
| Delivery | Long cycles | Short and Continuous |
| Infrastructure | OS Dependent, Vertically scaled, Pre-provisioned for peak load | OS independent, horizontal scaling, on-demand capacity |
| Maintenance/Recovery | In case of failure, whole system will go down, slow recovery | Fast recovery, whole system will never go down |


## Cloud native approach - Things to consider
Though cloud native approach looks promising with more advantages over traditional approach and improves the efficiency and productivity of the team, it comes with a price. Below are some of the things that need to be considered while designing cloud native apps.

1. How to split the application into independent logic units or services?
2. How to connect individual microservices so that the aggregate serves as a complete application?
3. Monitoring the health of Microservices (dead/alive) is important to make sure the request is handled properly
4. Debugging of microservices will be daunting if the number of microservices are more

There are tools which are production ready to solve the above issues. Discussion of these tools will take another post.


## Conclusion
Most of the organizations are moving their applications from private datacenters to public cloud platforms using cloud native architectural precepts. Learning and investing time on Cloud native applications will definitely uplift your resume/CV. In the next article we will discuss how to build a cloud native application from scratch and deploy it. Thanks for reading.</content><author><name>Saisyam</name><email>saisyam@saisyam.com</email></author><category term="Cloud" /><category term="Microservices" /><category term="CI/CD" /><category term="Containers" /><category term="Dockers" /><category term="DevOps" /><summary type="html">Cloud native is an approach to building and running applications that exploits the advantages of the cloud computing delivery model. In simple terms, Cloud native applications are built using cloud-based technologies, fully hosted and managed in the cloud.</summary></entry><entry><title type="html">Understanding Dockers and Containers</title><link href="/understanding-dockers-and-containers/" rel="alternate" type="text/html" title="Understanding Dockers and Containers" /><published>2020-10-13T00:00:00+05:30</published><updated>2020-10-13T00:00:00+05:30</updated><id>/understanding-dockers-and-containers</id><content type="html" xml:base="/understanding-dockers-and-containers/">&lt;p&gt;Dockers and containers are the building blocks for Cloud native development. Docker enables developers to build, run and ship applications that can be virtually run on any Operating System (OS). A running instance of a docker is called Container. In this article we will discuss about hardware and OS Virtualization, how docker works, docker workflow and commands to create and run docker.&lt;/p&gt;

&lt;p&gt;Docker bought a revolutionary change in Cloud Computing. Docker is inspired by a technology in Linux kernel called &lt;a href=&quot;https://linuxcontainers.org/&quot;&gt;LXC (Linux Containers)&lt;/a&gt;. LXC refers to the capabilites of Linux kernel, specifically namespaces and control groups, which allow sandboxing of processes from one another, and controlling their resource allocations. Docker utilizes the capabilities of LXC and hence it does not require any OS, instead it relies on the OS own functionality. LXC is a OS level virutalization method for running multiple isolated Linux systems (we call them containers) on a control host using a single Linux kernel.&lt;/p&gt;

&lt;h2 id=&quot;hardware-virutalization-vs-os-level-virtualization&quot;&gt;Hardware Virutalization vs OS Level Virtualization&lt;/h2&gt;
&lt;p&gt;If you use &lt;a href=&quot;https://www.vmware.com/in.html&quot;&gt;VMWare&lt;/a&gt; or &lt;a href=&quot;https://www.virtualbox.org/&quot;&gt;Virtualbox&lt;/a&gt;, then you are already using hardware virtualization. Below diagram shows the difference between the two.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/blog/virtualization.jpg&quot; alt=&quot;Virtualization&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The primary advantage of OS virtualiation is that multiple workloads can run on a single OS instance. With hardware virtualization (VMs), the hardware is being virtualized to run multiple OS instances.&lt;/p&gt;

&lt;h2 id=&quot;what-are-containers&quot;&gt;What are Containers?&lt;/h2&gt;
&lt;p&gt;OS virtualization had grown tremendously over the last decade. Containers sit on top of a physical server and its host OS (Linux/Windows). Each container shares the host OS kernel and libraries in a read-only mode. Containers are thus exceptionally light (few mega bytes) and will start in few seconds when compared to a VM. Containers’ speed, agility, and portability make them the primary tool to help building cloud native apps.&lt;/p&gt;

&lt;h2 id=&quot;what-is-a-docker&quot;&gt;What is a Docker?&lt;/h2&gt;
&lt;p&gt;Docker is a layered binary file with all the necessary ingredients to run an application. For example, I want to use PostgreSQL database in my project and I don’t want to install it on my machine. I can download PostgreSQL docker from &lt;a href=&quot;https://hub.docker.com/_/postgres&quot;&gt;docker hub&lt;/a&gt; and run it with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker&lt;/code&gt; command and use it for my development. You can also create your own docker for your application and upload that to docker hub for others to use. You can install docker community edition from &lt;a href=&quot;https://docs.docker.com/get-docker/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;lets-run-a-nginx-docker&quot;&gt;Let’s run a Nginx docker&lt;/h2&gt;
&lt;p&gt;In this section we will download and run nginx docker. &lt;a href=&quot;https://www.nginx.com/&quot;&gt;Nginx&lt;/a&gt; is a popular web server that is used in most of the production ready environments. In the process we will learn some basic docker commands.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker run &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; 80:80 nginx
Unable to find image &lt;span class=&quot;s1&quot;&gt;'nginx:latest'&lt;/span&gt; locally
latest: Pulling from library/nginx
bb79b6b2107f: Pull &lt;span class=&quot;nb&quot;&gt;complete 
&lt;/span&gt;111447d5894d: Pull &lt;span class=&quot;nb&quot;&gt;complete 
&lt;/span&gt;a95689b8e6cb: Pull &lt;span class=&quot;nb&quot;&gt;complete 
&lt;/span&gt;1a0022e444c2: Pull &lt;span class=&quot;nb&quot;&gt;complete 
&lt;/span&gt;32b7488a3833: Pull &lt;span class=&quot;nb&quot;&gt;complete 
&lt;/span&gt;Digest: sha256:ed7f815851b5299f616220a63edac69a4cc200e7f536a56e421988da82e44ed8
Status: Downloaded newer image &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;nginx:latest
/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
/docker-entrypoint.sh: Looking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;shell scripts &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; /docker-entrypoint.d/
/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh
10-listen-on-ipv6-by-default.sh: Getting the checksum of /etc/nginx/conf.d/default.conf
10-listen-on-ipv6-by-default.sh: Enabled listen on IPv6 &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; /etc/nginx/conf.d/default.conf
/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh
/docker-entrypoint.sh: Configuration &lt;span class=&quot;nb&quot;&gt;complete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; ready &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;start up
172.17.0.1 - - &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;20/Oct/2020:06:45:30 +0000] &lt;span class=&quot;s2&quot;&gt;&quot;GET / HTTP/1.1&quot;&lt;/span&gt; 200 612 &lt;span class=&quot;s2&quot;&gt;&quot;-&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Mozilla/5.0 (X11; Linux x86_64; rv:81.0) Gecko/20100101 Firefox/81.0&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;-&quot;&lt;/span&gt;
2020/10/20 06:45:30 &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;error] 28#28: &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;1 open&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/usr/share/nginx/html/favicon.ico&quot;&lt;/span&gt; failed &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;2: No such file or directory&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, client: 172.17.0.1, server: localhost, request: &lt;span class=&quot;s2&quot;&gt;&quot;GET /favicon.ico HTTP/1.1&quot;&lt;/span&gt;, host: &lt;span class=&quot;s2&quot;&gt;&quot;localhost&quot;&lt;/span&gt;, referrer: &lt;span class=&quot;s2&quot;&gt;&quot;http://localhost/&quot;&lt;/span&gt;
172.17.0.1 - - &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;20/Oct/2020:06:45:30 +0000] &lt;span class=&quot;s2&quot;&gt;&quot;GET /favicon.ico HTTP/1.1&quot;&lt;/span&gt; 404 153 &lt;span class=&quot;s2&quot;&gt;&quot;http://localhost/&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Mozilla/5.0 (X11; Linux x86_64; rv:81.0) Gecko/20100101 Firefox/81.0&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;-&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The above command &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run -p 80:80 nginx&lt;/code&gt; will pull &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nginx&lt;/code&gt; from &lt;a href=&quot;https://hub.docker.com/_/nginx&quot;&gt;docker hub&lt;/a&gt; as I don’t have it locally and runs it on port 80:80 (local:container). If I go to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://localhost/&lt;/code&gt; I will see nginx default html page with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Welcome to nginx!&lt;/code&gt; message. To kill it, simply press CTRL+C. To run the docker in the background or as daemon we will add &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-d&lt;/code&gt; option to the above command. List of some basic commands below:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Command&lt;/th&gt;
      &lt;th&gt;Action&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;docker images&lt;/td&gt;
      &lt;td&gt;Prints all local images&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;docker run &lt;image&gt;&lt;/image&gt;&lt;/td&gt;
      &lt;td&gt;Run a docker image&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;docker run -p &amp;lt;host-port:container-port&amp;gt; &amp;lt;image&amp;gt;&lt;/td&gt;
      &lt;td&gt;Run docker image with port forwarding from host to container&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;docker run -d &amp;lt;image&amp;gt;&lt;/td&gt;
      &lt;td&gt;Run docker image as daemon or in the background&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;docker run -e &amp;lt;environment variable&amp;gt; &amp;lt;image&amp;gt;&lt;/td&gt;
      &lt;td&gt;Run docker image with defined environment variable&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;docker ps&lt;/td&gt;
      &lt;td&gt;Displays all running containers&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;docker ps –all&lt;/td&gt;
      &lt;td&gt;Displays all containers including idle ones&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;docker kill &amp;lt;container-id&amp;gt;&lt;/td&gt;
      &lt;td&gt;Kill (force kill) the running docker image with the container id&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;docker rm &amp;lt;container-id&amp;gt;&lt;/td&gt;
      &lt;td&gt;Remove the container&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;docker-workflow&quot;&gt;Docker workflow&lt;/h2&gt;
&lt;p&gt;Below diagram shows the docker workflow. I have taken this image from a LinkedIn training.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/blog/docker_workflow.jpg&quot; alt=&quot;Docker Workflow&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At a high level the image explains:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Building docker images from docker file&lt;/li&gt;
  &lt;li&gt;Tagging docker images&lt;/li&gt;
  &lt;li&gt;Pushing docker images to docker hub&lt;/li&gt;
  &lt;li&gt;Pulling images from docker hub&lt;/li&gt;
  &lt;li&gt;Running docker images&lt;/li&gt;
  &lt;li&gt;Starting/stopping/restarting docker containers&lt;/li&gt;
  &lt;li&gt;Loading and saving docker images externally&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In this article we learn what is docker and container? We have learnt how to download and run a docker and some basic commands on managing docker images and containers. We have looked into docker workflow. In the coming articles we will see how to create our own docker and publish to docker hub. Thanks for reading.&lt;/p&gt;</content><author><name>Saisyam</name><email>saisyam@saisyam.com</email></author><category term="Cloud" /><category term="Dockers" /><category term="Containers" /><summary type="html">Dockers and containers are the building blocks for Cloud native development. Docker enables developers to build, run and ship applications that can be virtually run on any Operating System (OS). A running instance of a docker is called Container. In this article we will discuss about hardware and OS Virtualization, how docker works, docker workflow and commands to create and run docker.</summary></entry><entry><title type="html">Sentiment Analysis using Python Vader</title><link href="/sentiment-analysis-using-python-vader/" rel="alternate" type="text/html" title="Sentiment Analysis using Python Vader" /><published>2020-09-26T00:00:00+05:30</published><updated>2020-09-26T00:00:00+05:30</updated><id>/sentiment-analysis-using-python-vader</id><content type="html" xml:base="/sentiment-analysis-using-python-vader/">Sentiment analysis is a process of determining whether the given emotion (text) is postivie, negative or neutral. Sentiment Analysis is useful in identifying customers emotions for a service or product. In this article we will perform sentiment analysis on restaurant reviews. 

VADER(Valence Aware Dictionary and sEntiment Reasoner) is a lexicon and rule-based sentiment analysis tool that is specifically attuned to sentiments expressed in social media. VADER not only tells about the positivity and negativity score but also tells us about how positive or negative it is. VADER sentimental analysis relies on a dictionary that maps lexical features to emotion intensities known as sentiment scores. The sentiment score of a text can be obtained by summing up the intensity of each word in the text.

For example, words like, *'happy', 'awesome', 'good'* all convey positive emotion. VADER is intelligent enough to understand the context of these words. For example, *&quot;Food is not good&quot;* is considered negative. If also understands the emphasis of capitalization and punctuation. For example, *&quot;AWESOME&quot;* (capital letters) will represent the high intensity of positivity.


## Installing VADER Sentiment Analysis Tool
VADER is available as part of NLTK Python package. I use `pip3` to install Python packages. Below command will install `nltk`.
```shell
$ pip3 install nltk
```
Once `nltk` is installed, we need to download the `vader lexicon`.

```shell
$ python3
Python 3.8.5 (default, Sep  5 2020, 10:50:12) 
[GCC 10.2.0] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import nltk
&gt;&gt;&gt; nltk.download('vader_lexicon')
[nltk_data] Downloading package vader_lexicon to
[nltk_data]     /home/saisyam/nltk_data...
True
&gt;&gt;&gt; 
```
This will install required data for using VADER sentiment analysis.

## Performing Sentiment Analysis
We have everything installed to perform the sentiment analysis. Let's use VADER to find the sentiment of the following review:

*&quot;Pretty pricey but the lamb burger ($25) is beyond amazing. Definitely worth it. So, so good.&quot;*

The following code will perform the sentiment analysis.

```python
from nltk.sentiment.vader import SentimentIntensityAnalyzer
sia = SentimentIntensityAnalyzer()

text = &quot;Pretty pricey but the lamb burger ($25) is beyond amazing. Definitely worth it. So, so good.&quot;
sia.polarity_scores(text)
```
When we run the above code we get the following output:
```shell
&gt;&gt;&gt; {'neg': 0.0, 'neu': 0.369, 'pos': 0.631, 'compound': 0.963}
```
VADER's `SentimentIntensityAnalyzer()` takes in a string and returns a dictionary of scores in each of four categories:
* negative
* neutral
* positive
* compound (computed by normalizing the scores above)

The above result says that the emotion in the given review is *positive*. Let's look at the other review:
*&quot;The food is so good. The service is so bad.&quot;*
When we run the above code for the given text, the output is:
```shell
&gt;&gt;&gt; {'neg': 0.277, 'neu': 0.493, 'pos': 0.23, 'compound': -0.1901}
```
The review has two polarities. The customer is appreciating the food but not satisfied with the service. To judge whether the review is positive or negative we use the below logic.

```python
if compound &gt;= 0.05:
    print(&quot;Positive&quot;)
elif compound &lt;= -0.05:
    print(&quot;Negative&quot;)
else:
    print(&quot;Neutral&quot;)
```
Which says the above review is *negative*.


## What is missing with VADER Sentiment Analysis?
VADER only tries to get the emotion (postivie/negative/neutral) out of text. It won't care about the aspect. For example, the review,
*&quot;The food is so good. The service is so bad.&quot;* is *negative* from the `service` aspect but *postive* from the `food` aspect. If we identify sentiment based on aspects then it will be much more helpful. This is called *Aspect based Sentiment Analysis*.

## Conclusion
In this post we have learnt how to find whether the text is positive, negative or neutral using Python based VADER Sentiment Analysis. We also discussed the next level of sentiment analysis based on aspects. In the next article we will see how we can identify aspects for a given industry or domain and implement the sentiment analysis based on aspects.</content><author><name>Saisyam</name><email>saisyam@saisyam.com</email></author><category term="Python" /><category term="Sentiment analysis" /><category term="Text Analytics" /><category term="Vader" /><summary type="html">Sentiment analysis is a process of determining whether the given emotion (text) is postivie, negative or neutral. Sentiment Analysis is useful in identifying customers emotions for a service or product. In this article we will perform sentiment analysis on restaurant reviews.</summary></entry><entry><title type="html">Proven way to Fake Webcam in Test Automation with Python</title><link href="/fake-webcam-in-test-automation-with-python/" rel="alternate" type="text/html" title="Proven way to Fake Webcam in Test Automation with Python" /><published>2020-06-07T00:00:00+05:30</published><updated>2020-06-07T00:00:00+05:30</updated><id>/fake-webcam-in-test-automation-with-python</id><content type="html" xml:base="/fake-webcam-in-test-automation-with-python/">We automate web application testing using Python Selenium or Splinter. How will you automate testing applications with webcam? You can fake a webcam device with Chrome Web driver. In this article we will see how to do that.

## Challenge
The challenge here is to fake the webcam with proper video format. In this post I am using Chrome browser along with [Splinter](https://splinter.readthedocs.io/en/latest/).
If you are new to Splinter, check out my article and I promise you love it. We use Splinter not only for testing but also for web scraping. Chrome need Y4M format to replace the camera feed. To generate that format you need [ffmpeg](https://www.ffmpeg.org/) tool. Using that tool you can convert any MP4 video into Y4M format.

&gt; Y4M is an un-compressed format. The converted Y4M file size will be almost three times the MP4 file. So, take a small MP4 file or repeat the image to create the video.


Once you have the Y4M file you can follow the below mentioned steps to fake the webcam. [Here](https://testrtc.com/y4m-video-chrome/) is an article on how to create Y4M files using [ffmpeg](https://www.ffmpeg.org/).

## Chrome Settings to fake webcam

We will set `webdriver.ChromeOptions` to enable media stream using a fake device.

{% gist 98aa0345e2a470b39d754b35b7910596 %}

## Conclusion
You are all set to test the web applications uing a fake video. The complete source code along with the sample web application (using Python Flask) is available as a [gitlab project](https://gitlab.com/saisyam/web-automation-testing/-/tree/master/fake_webcam).</content><author><name>Saisyam</name><email>saisyam@saisyam.com</email></author><category term="Python" /><category term="Web Testing" /><category term="Splinter" /><category term="ffmpeg" /><category term="Fake webcam" /><summary type="html">We automate web application testing using Python Selenium or Splinter. How will you automate testing applications with webcam? You can fake a webcam device with Chrome Web driver. In this article we will see how to do that.</summary></entry></feed>